# Lab 0 - Up and running with C++

For the most part you've all been using Java in your programming classes. You should also have been exposed to
a little bit of C. In CSCI 441 you'll be using C++. 
This lab aims to familiarize you with some features of C++ that are different than or missing from Java and C that 
you may use in this class or in the future.

## Part 1 - main function and command-line arguments

Just like in C and similar to Java, a main function is required to run a C++ program. The arguments passed to that function
represent any command-line arguments (the first argument is always the filename of the program). Unlike Java, C++ doesn't 
have a built-in array type that keeps track of its own length. So, in addition to an array with the string data for the command-line arguments,
we also need an integer variable describing how many strings there are. The main function in C and C++ also must return an integer. This is what
your main function should look like:

    int main(int argc, char** argv) {

    }

**Create a main.cpp file and add a main function to it**

## Part 2 - g++, Makefiles and qmake

To compile and run your code type the following in a terminal:

    $ g++ main.cpp -o lab0
    $ ./lab0

Our program is very simple (in fact, it does nothing!), so the build command is also very simple. Once we start having multiple files with libraries that we 
reference, the build process
can start to get complicated. Large projects often compile code in many different g++ commands with a number of different include and library paths. 
It can quickly become a pain to manually type the g++ commands. The standard way to build a C++ project is to construct (or generate) a Makefile, which 
will run all the build steps (or just the ones we specify) using the `make` command.

**Create a file called Makefile with the following text (note that there must be a single tab character before the g++ command):**

    lab0: main.cpp
    	g++ main.cpp -o lab0

    all: lab0

This is a very simplistic Makefile, and is the only one that you'll write the rest of the semester. When you run the `make` or `make all` command, it 
runs the `all` rule in the Makefile. In this case, the `all` rule has a single dependency, `lab0`. `make` checks whether a file `lab0` exists and, if
it does, whether the last timestamp on the file is more up-to-date than any of its dependencies. So, if main.cpp has been modified more recently than
the `lab0` executable, `make` will run the g++ command we provided, otherwise we get a `lab0 is up to date` message. Larger projects will have much more
complicated rules for building the whole project. Makefiles are often generated by other programs that detect information about the system you're compiling
for, what compiler is installed, what libraries are installed, etc. 
    
Enter `qmake`, the tool we'll be using to generate our Makefiles. `qmake` comes with Qt, a popular cross platform GUI library for C++ (and bindings for many
other languages) that we'll be using throughout the semester. `qmake` looks for a project file (a .pro file) and generates a Makefile from the information
contained within it.

**Create a lab0.pro file with the following text:**

    SOURCES = main.cpp
    CONFIG -= app_bundle
    CONFIG += console

Now run the `qmake` command. On the Fedora lab machines, there are multiple versions of `qmake` installed. Use `qmake-qt5` whenever I say to run `qmake`. I recommend making
an alias (ask me and I can help you set this up). Open the `Makefile` that it generated. You'll notice that it's a whole lot more complicated than the
one we wrote previously, but you can now type `make` to build your project:

    $ make
    $ ./lab0

## Part 3 - Namespaces

C++ uses namespaces to help prevent name clashes in large projects or with external libraries. 
The C++ standard libraries all use the std namespace.
To reference a variable, class or function within a namespace you prefix it with its namespace and a :: (i.e. `std::vector`).
You can save a few keystrokes and avoid having to type the std:: by including `using namespace std;`. It can be a bad idea to 
add an entire namespace into global scope as it can introduce naming conflicts. Instead, you can also bring individual functions 
or variables into global scope by typing `using std::<name you'd like to use>`. For example, `using std::cout;` allows you to simply
type `cout` now, rather than `std::cout`. Throughout the semester, you'll frequently be using the std:: and glm:: 
namespaces. There is no specific deliverable for this part, but you'll need to be aware of namespaces to better understand some of the following
parts and future labs.

## Part 4 - Basic terminal I/O

Basic I/O in C++ requires including the iostream standard library. 

**Add this line to the top of your main.cpp file:**

    #include <iostream>

### Part 4a - Output

Writing to the terminal is achieved using `std::cout` and the `<<` operator. You can use `<<` to output strings, any of the basic types
and even your own custom objects by overloading the `<<` operator (see below for operator overloading). You'll often see many `<<` operators
chained in a single statement, for example:

    std::cout << "hello world " << argv[0] << " " << 1234 << " " << std::endl;

The `std::endl` at the end of the above statement evaluates to the newline character ('\n'), and then flushes the stream. With `std::cout` that
means that any output that is currently buffered will be output to the terminal.

**Print out all provided command-line arguments to the terminal**

### Part 4b - Input

Reading from the terminal is achieved using `std::cin` and the `>>` operator. Again, the `>>` operator works with strings and any basic
types and by using operator overloading you can get it to work with your own custom objects. For this lab, read a name into a std::string (type
`#include <string>` at the top of main.cpp)
object, then change your cout statement to print "hello &lt;entered name&gt;" instead. 


**Prompt the user for their name and once entered print "hello &lt;what the user types&gt;" to the terminal**

## Part 5 - Classes and structs

You may be familiar with structs from C. In C++, in addition to member variables, structs can also have methods. For example:

    struct vec3 {
        float x;
        float y;
        float z;

        float lengthSquared() {
            return x*x+y*y+z*z;
        }
    };

In C++, a class is exactly the same as a struct, except by default its members are private, whereas for a struct they are public. 
For structs or classes you can change the visibility of methods and variables by using the public, private and protected specifiers:

    class Foo {
        private:
            float a; // only available to methods of Foo
            int b;
            char c;

            void bar(); 

        protected:
            float d; // only available to methods of Foo or objects that inherit from Foo
            int e;
            char f;

            void blah();

        public:
            float g; // available anywhere
            int h;
            char i;

            void foo(); 
    };

Constructors are defined like a method with the same name as the class without a return type and are called when an object is initialized. 
Member variables can be initialized using a : after the arguments, but before any code that runs. Destructors 
are defined using a ~ before the name of the class with no return type or arguments. An object's destructor is called when 
it goes out of scope or destroyed.

    class Vector3 {
        public:
            float x;
            float y;
            float z;

            // Constructor
            Vector3(float xx, float yy, float zz) : x(xx), y(yy), z(zz) {
                // nothing to do here as we've already initialized x, y, and z above
                std::cout << "in Vector3 constructor" << std::endl;
            }

            // Destructor - called when an object goes out of scope or is destroyed
            ~Vector3() {
                // this is where you would release resources such as memory or file descriptors
                // in this case we don't need to do anything
                std::cout << "in Vector3 destructor" << std::endl;
            }
    };

Unlike Java, objects in C++ can be created on the stack and passed by value to functions:

    Vector3 add(Vector3 v, Vector3 v2) { // v and v2 are copies, so any changes to them in this function
                                         // won't affect the originals
        // ...
    } 

    int main(int argc, char** argv) {
        Vector3 a(1,2,3);   // allocated to the stack
        Vector3 b(4,5,6);

        Vector3 c = add(a,b); // copies 6 floats to the arguments in add (3 per Vector3),
                              // 3 more floats copied into c when it returns
                              // a and b are unchanged

    }

This can result in a lot of overhead if used inappropriately. It can also be helpful for many cases.
In graphics, vectors and matrices are used often and it can be more efficient to allocate vector and matrix objects to the stack rather
than incurring memory allocations. We'll see an example of this in a later part. 

**Copy the definition of Vector3 into your main.cpp file, just above the main function and finish the implementation of the `Vector3 add(Vector3 v, Vector3 v2)` function. 
Ensure `add` is working by adding two vectors together and printing out the result.**

## Part 6 - Operator overloading

A major feature of C++ that doesn't exist in Java is operator overloading. Operator overloading allows you to implement your own functions and
methods for the builtin operators (+,-,\*,/,etc.) for objects and enumerations. Operator overloading gets a bad wrap because when poorly used,
can lead to unreadable or misleading code. When used well, though, operator overloading can result in consiser, more readable code. One of the best examples of
a good use for operator overloading is when implementing vector and matrix math. Vector addition is a very standard operation, so it would make complete
sense to be able to write `vector1+vector2` just like you would when adding two integers or floats. Unfortunately, in Java, you'd be forced to write
something like `vector1.add(vector2)`. This isn't so bad if you're just adding two vectors, but once you start getting more complicated and take into account
that you can't allocate objects to the stack, it can quickly
get messy. For example, here's the equation for a cubic Bezier from Wikipedia, where B, P0, P1, and P2 are vectors:

![(1-t)^2*P0+2*(1-t)*t*P1+t^2*P2](https://upload.wikimedia.org/math/4/8/e/48eb1b219c5469ba72b738719b15adf0.png).

Which would you say is a more readable way to implement it in code?

    // Vector3 P0, P1, P2 defined elsewhere
    // float t defined elsewhere
    B = (1-t)*(1-t)*P0 + 2*(1-t)*t*P1 + t*t*P2; 
    
or 

    // Vector3 P0, P1, P2 defined elsewhere
    // float t defined elsewhere
    Vector3 tmp0, tmp1, tmp2;
    tmp0 = P0.copy();
    tmp1 = P1.copy();
    tmp2 = P2.copy();

    tmp0.multiply((1-t)*(1-t));
    tmp1.multiply(2*(1-t)*t);
    tmp2.multiply(t*t);

    tmp0.add(tmp1);
    tmp0.add(tmp2);

    B = tmp0;

In C++, you can achieve the first implementation with operator overloading. 
Define `Vector3 operator+(Vector3 v, Vector3 v2)` and it will be called when two vectors are added and define `Vector3 operator*(float s, Vector3 v)` and 
it will be called when a float and vector are multiplied together (you may also want to define `Vector3 operator*(Vector3 v, float s)` to handle multiplication
in reverse order).

**Implement `Vector3 operator+(Vector3 v, Vector3 v2)` so that it performs vector addition**

If you want to be able to output your own custom objects using `std::cout` you can overload the `<<` operator. For Vector3, you need to implement
`std::ostream& operator<<(std::ostream& stream, const Vector3& v)`. 

**Copy the following code into main.cpp and finish the implementation**

    std::ostream& operator<<(std::ostream& stream, const Vector3& v) {
        // std::cout is a std::ostream object, just like stream
        // so use stream as if it were cout and output the components of
        // the vector

        return stream;
    }


The following code should output "5, 7, 9":

    Vector3 v(1,2,3);
    Vector3 v2(4,5,6);

    std::cout << v+v2 << std::endl;


## Part 7 - Pointers, arrays, new and delete

Pointers are a location in memory. In Java, every object is a pointer because they are all allocated to the heap (unless the compiler is able to
optimize your code for you, but you have no control over this). This means the syntax for accessing object methods and member variables in Java can be 
simplified (they all use the dot (.) syntax). 
In C++, pointers have extra syntax. You can get a pointer to 
any variable by using the `&` operator.  You can dereference a pointer by using the `*` operator. If the pointer is to a struct or class object, then
you can access member variables or methods using the `->` operator.

    int i = 5;
    int* pointer_to_i = &i;

    cout << *pointer_to_i << endl; // will print out 5

    struct coord {
        float x;
        float y;
        float z;
    };
    coord pt;
    coord* pointer_to_pt = &pt;
    pointer_to_pt->x = 5;

    cout << pt.x << endl; // prints 5
    cout << (*pointer_to_pt).x << endl; // also prints 5

**Allocate a Vector3 on the stack initialized to (0,0,0). Set its y component to 5, then output it to the terminal using the overloaded `<<` operator**

The `new` operator allocates enough memory to create an object (or basic type) on the heap, calls the object's constructor, then returns a pointer
to it. When you're done with that memory you should release it by using the `delete` operator. Unlike Java, there is no automatic garbage 
collection in C++ so you can easily have memory leaks by not deleting memory you've allocated with new.
new and delete are a little fancier than C's malloc and free. Memory allocation is a relatively slow operation, so for some graphics situations
it can really bog down your program. Temporary variables should really be allocated to the stack. In Java,
because you can't allocate objects to the stack (unless the compiler figures out it can optimize it that way), it can be a little awkward
to do vector and matrix math (like the Bezier curve example above).

    struct point {
        float x;
        float y;
        float z;
    };

    point* pt = new point; // allocate a point

    pt->x = 5;

    delete pt; // delete the memory when you're done with it

    // In this case this would have been faster because it avoids a heap allocation
    point pt;
    pt.x = 5;

**Allocate a Vector3 on the heap initialized to (0,0,0). Set its y component to 5, then output it to the terminal using the overloaded `<<` operator. 
Delete the Vector3 when you're done with it.**

## Part 8 - Arrays

An array of a given type can be allocated to the stack by adding square brackets to the definition. The size of the array must be known at compile time.
An array variable can be treated as a pointer to the first value in the array.

    int array[10];
    int* ptr = array;

    // array and ptr can almost be treated identically
    // differences include compile time information such as sizeof(array) vs sizeof(ptr)

You may be tempted to put a dynamic value inside the
square brackets, but its not part of the C++ standard (search for variable length arrays for more information). You may find that a value
only know at runtime happens to compile on your machine. Be careful, though, as it probably won't work on someone else's computer. Some compilers
choose to allow this behavior, as it is part of the C99 specification and as an extension for C++. To be safe, if you want to allocate a 
dynamic amount of memory, use `new` to do so on the heap (see below).

**Allocate an array of 10 Vector3 objects on the stack (make any necessary changes to get your code to compile).**

The `new` operator can also be used to allocate an array of data by using square brackets. To free an array requires square brackets 
in the `delete` as well.

    int* array_of_ints = new int[100]; // allocates 100 consecutive ints and returns a pointer to the first one

    delete [] array_of_ints; // frees all the memory we just allocated

**Allocate an array of 10 Vector3's on the heap. Set the y component for all of them to 5.**

## Part 9 - References

A reference, like a pointer, refers to a location in memory. Unlike a pointer, though, a reference cannot be reassigned to another location. A reference
automatically behaves like the object or variable it refers to without the need to dereference it, making
it essentially an alias to another variable. References are recommended over pointers when possible,
but it's really a matter of preference. A reference is defined by using an `&` in the declaration:

    int i = 0;
    int& j = i;

    j = 5;

    std::cout << i << std::endl; // prints 5

References are often used as function parameters to avoid unnecessary copies (just like a pointer would be). Const references can even further
improve performance by allowing the compiler to make certain optimazations, so if you don't need to change the data that is being referenced,
declare it `const`, as well.

**Change the arguments to `add` and `operator+` functions to be const references and notice how the number of Vector3 constructor and destructor calls changes (feel free to comment out code from previous parts).**
